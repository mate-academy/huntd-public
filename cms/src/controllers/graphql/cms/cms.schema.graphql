input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

enum ENUM_CANDIDATEPROFILES_STATUS {
  DRAFT
  ON_REVIEW
  REJECTED
  ACTIVE
  INACTIVE
}

type CandidateProfiles {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  status: ENUM_CANDIDATEPROFILES_STATUS!
  position: String
  salary: Float
  candidate_description: String
  experience_description: String
  reject_reason: String
  user_id: HuntdUsers
  achievements: String
  profile_connections(sort: String, limit: Int, start: Int, where: JSON): [ProfileConnections]
}

type CandidateProfilesConnection {
  values: [CandidateProfiles]
  groupBy: CandidateProfilesGroupBy
  aggregate: CandidateProfilesAggregator
}

type CandidateProfilesAggregator {
  count: Int
  totalCount: Int
  sum: CandidateProfilesAggregatorSum
  avg: CandidateProfilesAggregatorAvg
  min: CandidateProfilesAggregatorMin
  max: CandidateProfilesAggregatorMax
}

type CandidateProfilesAggregatorSum {
  salary: Float
}

type CandidateProfilesAggregatorAvg {
  salary: Float
}

type CandidateProfilesAggregatorMin {
  salary: Float
}

type CandidateProfilesAggregatorMax {
  salary: Float
}

type CandidateProfilesGroupBy {
  id: [CandidateProfilesConnectionId]
  created_at: [CandidateProfilesConnectionCreated_at]
  updated_at: [CandidateProfilesConnectionUpdated_at]
  status: [CandidateProfilesConnectionStatus]
  position: [CandidateProfilesConnectionPosition]
  salary: [CandidateProfilesConnectionSalary]
  candidate_description: [CandidateProfilesConnectionCandidate_description]
  experience_description: [CandidateProfilesConnectionExperience_description]
  reject_reason: [CandidateProfilesConnectionReject_reason]
  user_id: [CandidateProfilesConnectionUser_id]
  achievements: [CandidateProfilesConnectionAchievements]
}

type CandidateProfilesConnectionId {
  key: ID
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionCreated_at {
  key: DateTime
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionUpdated_at {
  key: DateTime
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionStatus {
  key: String
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionPosition {
  key: String
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionSalary {
  key: Float
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionCandidate_description {
  key: String
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionExperience_description {
  key: String
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionReject_reason {
  key: String
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionUser_id {
  key: ID
  connection: CandidateProfilesConnection
}

type CandidateProfilesConnectionAchievements {
  key: String
  connection: CandidateProfilesConnection
}

input CandidateProfileInput {
  status: ENUM_CANDIDATEPROFILES_STATUS
  position: String
  salary: Float
  candidate_description: String
  experience_description: String
  reject_reason: String
  user_id: ID
  profile_connections: [ID]
  achievements: String
  created_by: ID
  updated_by: ID
}

input editCandidateProfileInput {
  status: ENUM_CANDIDATEPROFILES_STATUS
  position: String
  salary: Float
  candidate_description: String
  experience_description: String
  reject_reason: String
  user_id: ID
  profile_connections: [ID]
  achievements: String
  created_by: ID
  updated_by: ID
}

input createCandidateProfileInput {
  data: CandidateProfileInput
}

type createCandidateProfilePayload {
  candidateProfile: CandidateProfiles
}

input updateCandidateProfileInput {
  where: InputID
  data: editCandidateProfileInput
}

type updateCandidateProfilePayload {
  candidateProfile: CandidateProfiles
}

input deleteCandidateProfileInput {
  where: InputID
}

type deleteCandidateProfilePayload {
  candidateProfile: CandidateProfiles
}

enum ENUM_DEVICETOKENS_DEVICE_PLATFORM {
  IOS
  ANDROID
}

type DeviceTokens {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  token: String
  device_name: String
  device_platform: ENUM_DEVICETOKENS_DEVICE_PLATFORM
  system_version: String
  device_year: String
  user_id: HuntdUsers
  published_at: DateTime
}

type DeviceTokensConnection {
  values: [DeviceTokens]
  groupBy: DeviceTokensGroupBy
  aggregate: DeviceTokensAggregator
}

type DeviceTokensAggregator {
  count: Int
  totalCount: Int
}

type DeviceTokensGroupBy {
  id: [DeviceTokensConnectionId]
  created_at: [DeviceTokensConnectionCreated_at]
  updated_at: [DeviceTokensConnectionUpdated_at]
  token: [DeviceTokensConnectionToken]
  device_name: [DeviceTokensConnectionDevice_name]
  device_platform: [DeviceTokensConnectionDevice_platform]
  system_version: [DeviceTokensConnectionSystem_version]
  device_year: [DeviceTokensConnectionDevice_year]
  user_id: [DeviceTokensConnectionUser_id]
  published_at: [DeviceTokensConnectionPublished_at]
}

type DeviceTokensConnectionId {
  key: ID
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionCreated_at {
  key: DateTime
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionUpdated_at {
  key: DateTime
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionToken {
  key: String
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionDevice_name {
  key: String
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionDevice_platform {
  key: String
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionSystem_version {
  key: String
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionDevice_year {
  key: String
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionUser_id {
  key: ID
  connection: DeviceTokensConnection
}

type DeviceTokensConnectionPublished_at {
  key: DateTime
  connection: DeviceTokensConnection
}

input DeviceTokenInput {
  token: String
  device_name: String
  device_platform: ENUM_DEVICETOKENS_DEVICE_PLATFORM
  system_version: String
  device_year: String
  user_id: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editDeviceTokenInput {
  token: String
  device_name: String
  device_platform: ENUM_DEVICETOKENS_DEVICE_PLATFORM
  system_version: String
  device_year: String
  user_id: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createDeviceTokenInput {
  data: DeviceTokenInput
}

type createDeviceTokenPayload {
  deviceToken: DeviceTokens
}

input updateDeviceTokenInput {
  where: InputID
  data: editDeviceTokenInput
}

type updateDeviceTokenPayload {
  deviceToken: DeviceTokens
}

input deleteDeviceTokenInput {
  where: InputID
}

type deleteDeviceTokenPayload {
  deviceToken: DeviceTokens
}

type EnglishLevel {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  slug: String
  published_at: DateTime
}

type EnglishLevelConnection {
  values: [EnglishLevel]
  groupBy: EnglishLevelGroupBy
  aggregate: EnglishLevelAggregator
}

type EnglishLevelAggregator {
  count: Int
  totalCount: Int
}

type EnglishLevelGroupBy {
  id: [EnglishLevelConnectionId]
  created_at: [EnglishLevelConnectionCreated_at]
  updated_at: [EnglishLevelConnectionUpdated_at]
  slug: [EnglishLevelConnectionSlug]
  published_at: [EnglishLevelConnectionPublished_at]
}

type EnglishLevelConnectionId {
  key: ID
  connection: EnglishLevelConnection
}

type EnglishLevelConnectionCreated_at {
  key: DateTime
  connection: EnglishLevelConnection
}

type EnglishLevelConnectionUpdated_at {
  key: DateTime
  connection: EnglishLevelConnection
}

type EnglishLevelConnectionSlug {
  key: String
  connection: EnglishLevelConnection
}

type EnglishLevelConnectionPublished_at {
  key: DateTime
  connection: EnglishLevelConnection
}

input EnglishLevelInput {
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editEnglishLevelInput {
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createEnglishLevelInput {
  data: EnglishLevelInput
}

type createEnglishLevelPayload {
  englishLevel: EnglishLevel
}

input updateEnglishLevelInput {
  where: InputID
  data: editEnglishLevelInput
}

type updateEnglishLevelPayload {
  englishLevel: EnglishLevel
}

input deleteEnglishLevelInput {
  where: InputID
}

type deleteEnglishLevelPayload {
  englishLevel: EnglishLevel
}

enum ENUM_FEATURES_STATUS {
  ENABLED
  DISABLED
}

type Features {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  description: String
  status: ENUM_FEATURES_STATUS
}

type FeaturesConnection {
  values: [Features]
  groupBy: FeaturesGroupBy
  aggregate: FeaturesAggregator
}

type FeaturesAggregator {
  count: Int
  totalCount: Int
}

type FeaturesGroupBy {
  id: [FeaturesConnectionId]
  created_at: [FeaturesConnectionCreated_at]
  updated_at: [FeaturesConnectionUpdated_at]
  name: [FeaturesConnectionName]
  description: [FeaturesConnectionDescription]
  status: [FeaturesConnectionStatus]
}

type FeaturesConnectionId {
  key: ID
  connection: FeaturesConnection
}

type FeaturesConnectionCreated_at {
  key: DateTime
  connection: FeaturesConnection
}

type FeaturesConnectionUpdated_at {
  key: DateTime
  connection: FeaturesConnection
}

type FeaturesConnectionName {
  key: String
  connection: FeaturesConnection
}

type FeaturesConnectionDescription {
  key: String
  connection: FeaturesConnection
}

type FeaturesConnectionStatus {
  key: String
  connection: FeaturesConnection
}

input FeatureInput {
  name: String
  description: String
  status: ENUM_FEATURES_STATUS
  created_by: ID
  updated_by: ID
}

input editFeatureInput {
  name: String
  description: String
  status: ENUM_FEATURES_STATUS
  created_by: ID
  updated_by: ID
}

input createFeatureInput {
  data: FeatureInput
}

type createFeaturePayload {
  feature: Features
}

input updateFeatureInput {
  where: InputID
  data: editFeatureInput
}

type updateFeaturePayload {
  feature: Features
}

input deleteFeatureInput {
  where: InputID
}

type deleteFeaturePayload {
  feature: Features
}

type HuntdUsers {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  email: String
  first_name: String
  last_name: String
  cv: UploadFile
  recruiter_profiles(sort: String, limit: Int, start: Int, where: JSON): [RecruiterProfiles]
  candidate_profiles(sort: String, limit: Int, start: Int, where: JSON): [CandidateProfiles]
  vacancies_sources(sort: String, limit: Int, start: Int, where: JSON): [VacanciesSources]
}

type HuntdUsersConnection {
  values: [HuntdUsers]
  groupBy: HuntdUsersGroupBy
  aggregate: HuntdUsersAggregator
}

type HuntdUsersAggregator {
  count: Int
  totalCount: Int
}

type HuntdUsersGroupBy {
  id: [HuntdUsersConnectionId]
  created_at: [HuntdUsersConnectionCreated_at]
  updated_at: [HuntdUsersConnectionUpdated_at]
  email: [HuntdUsersConnectionEmail]
  first_name: [HuntdUsersConnectionFirst_name]
  last_name: [HuntdUsersConnectionLast_name]
  cv: [HuntdUsersConnectionCv]
}

type HuntdUsersConnectionId {
  key: ID
  connection: HuntdUsersConnection
}

type HuntdUsersConnectionCreated_at {
  key: DateTime
  connection: HuntdUsersConnection
}

type HuntdUsersConnectionUpdated_at {
  key: DateTime
  connection: HuntdUsersConnection
}

type HuntdUsersConnectionEmail {
  key: String
  connection: HuntdUsersConnection
}

type HuntdUsersConnectionFirst_name {
  key: String
  connection: HuntdUsersConnection
}

type HuntdUsersConnectionLast_name {
  key: String
  connection: HuntdUsersConnection
}

type HuntdUsersConnectionCv {
  key: ID
  connection: HuntdUsersConnection
}

input HuntdUserInput {
  email: String
  first_name: String
  last_name: String
  recruiter_profiles: [ID]
  candidate_profiles: [ID]
  cv: ID
  vacancies_sources: [ID]
  created_by: ID
  updated_by: ID
}

input editHuntdUserInput {
  email: String
  first_name: String
  last_name: String
  recruiter_profiles: [ID]
  candidate_profiles: [ID]
  cv: ID
  vacancies_sources: [ID]
  created_by: ID
  updated_by: ID
}

input createHuntdUserInput {
  data: HuntdUserInput
}

type createHuntdUserPayload {
  huntdUser: HuntdUsers
}

input updateHuntdUserInput {
  where: InputID
  data: editHuntdUserInput
}

type updateHuntdUserPayload {
  huntdUser: HuntdUsers
}

input deleteHuntdUserInput {
  where: InputID
}

type deleteHuntdUserPayload {
  huntdUser: HuntdUsers
}

type JobExperience {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  slug: String
  published_at: DateTime
}

type JobExperienceConnection {
  values: [JobExperience]
  groupBy: JobExperienceGroupBy
  aggregate: JobExperienceAggregator
}

type JobExperienceAggregator {
  count: Int
  totalCount: Int
}

type JobExperienceGroupBy {
  id: [JobExperienceConnectionId]
  created_at: [JobExperienceConnectionCreated_at]
  updated_at: [JobExperienceConnectionUpdated_at]
  slug: [JobExperienceConnectionSlug]
  published_at: [JobExperienceConnectionPublished_at]
}

type JobExperienceConnectionId {
  key: ID
  connection: JobExperienceConnection
}

type JobExperienceConnectionCreated_at {
  key: DateTime
  connection: JobExperienceConnection
}

type JobExperienceConnectionUpdated_at {
  key: DateTime
  connection: JobExperienceConnection
}

type JobExperienceConnectionSlug {
  key: String
  connection: JobExperienceConnection
}

type JobExperienceConnectionPublished_at {
  key: DateTime
  connection: JobExperienceConnection
}

input JobExperienceInput {
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editJobExperienceInput {
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createJobExperienceInput {
  data: JobExperienceInput
}

type createJobExperiencePayload {
  jobExperience: JobExperience
}

input updateJobExperienceInput {
  where: InputID
  data: editJobExperienceInput
}

type updateJobExperiencePayload {
  jobExperience: JobExperience
}

input deleteJobExperienceInput {
  where: InputID
}

type deleteJobExperiencePayload {
  jobExperience: JobExperience
}

enum ENUM_PROFILECONNECTIONS_STATUS {
  APPROVED
  REJECTED
  PENDING
}

type ProfileConnections {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  paid_at: DateTime
  candidate_profile_id: CandidateProfiles
  recruiter_profile_id: RecruiterProfiles
  status: ENUM_PROFILECONNECTIONS_STATUS
  is_payment_requested: Boolean
  recruiter_user_id: HuntdUsers
}

type ProfileConnectionsConnection {
  values: [ProfileConnections]
  groupBy: ProfileConnectionsGroupBy
  aggregate: ProfileConnectionsAggregator
}

type ProfileConnectionsAggregator {
  count: Int
  totalCount: Int
}

type ProfileConnectionsGroupBy {
  id: [ProfileConnectionsConnectionId]
  created_at: [ProfileConnectionsConnectionCreated_at]
  updated_at: [ProfileConnectionsConnectionUpdated_at]
  paid_at: [ProfileConnectionsConnectionPaid_at]
  candidate_profile_id: [ProfileConnectionsConnectionCandidate_profile_id]
  recruiter_profile_id: [ProfileConnectionsConnectionRecruiter_profile_id]
  status: [ProfileConnectionsConnectionStatus]
  is_payment_requested: [ProfileConnectionsConnectionIs_payment_requested]
  recruiter_user_id: [ProfileConnectionsConnectionRecruiter_user_id]
}

type ProfileConnectionsConnectionId {
  key: ID
  connection: ProfileConnectionsConnection
}

type ProfileConnectionsConnectionCreated_at {
  key: DateTime
  connection: ProfileConnectionsConnection
}

type ProfileConnectionsConnectionUpdated_at {
  key: DateTime
  connection: ProfileConnectionsConnection
}

type ProfileConnectionsConnectionPaid_at {
  key: DateTime
  connection: ProfileConnectionsConnection
}

type ProfileConnectionsConnectionCandidate_profile_id {
  key: ID
  connection: ProfileConnectionsConnection
}

type ProfileConnectionsConnectionRecruiter_profile_id {
  key: ID
  connection: ProfileConnectionsConnection
}

type ProfileConnectionsConnectionStatus {
  key: String
  connection: ProfileConnectionsConnection
}

type ProfileConnectionsConnectionIs_payment_requested {
  key: Boolean
  connection: ProfileConnectionsConnection
}

type ProfileConnectionsConnectionRecruiter_user_id {
  key: ID
  connection: ProfileConnectionsConnection
}

input ProfileConnectionInput {
  paid_at: DateTime
  candidate_profile_id: ID
  recruiter_profile_id: ID
  status: ENUM_PROFILECONNECTIONS_STATUS
  is_payment_requested: Boolean
  recruiter_user_id: ID
  created_by: ID
  updated_by: ID
}

input editProfileConnectionInput {
  paid_at: DateTime
  candidate_profile_id: ID
  recruiter_profile_id: ID
  status: ENUM_PROFILECONNECTIONS_STATUS
  is_payment_requested: Boolean
  recruiter_user_id: ID
  created_by: ID
  updated_by: ID
}

input createProfileConnectionInput {
  data: ProfileConnectionInput
}

type createProfileConnectionPayload {
  profileConnection: ProfileConnections
}

input updateProfileConnectionInput {
  where: InputID
  data: editProfileConnectionInput
}

type updateProfileConnectionPayload {
  profileConnection: ProfileConnections
}

input deleteProfileConnectionInput {
  where: InputID
}

type deleteProfileConnectionPayload {
  profileConnection: ProfileConnections
}

enum ENUM_RECRUITERPROFILES_STATUS {
  DRAFT
  ON_REVIEW
  REJECTED
  ACTIVE
  INACTIVE
}

type RecruiterProfiles {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  status: ENUM_RECRUITERPROFILES_STATUS!
  position: String
  company_name: String
  user_id: HuntdUsers
  reject_reason: String
  profile_connections(sort: String, limit: Int, start: Int, where: JSON): [ProfileConnections]
}

type RecruiterProfilesConnection {
  values: [RecruiterProfiles]
  groupBy: RecruiterProfilesGroupBy
  aggregate: RecruiterProfilesAggregator
}

type RecruiterProfilesAggregator {
  count: Int
  totalCount: Int
}

type RecruiterProfilesGroupBy {
  id: [RecruiterProfilesConnectionId]
  created_at: [RecruiterProfilesConnectionCreated_at]
  updated_at: [RecruiterProfilesConnectionUpdated_at]
  status: [RecruiterProfilesConnectionStatus]
  position: [RecruiterProfilesConnectionPosition]
  company_name: [RecruiterProfilesConnectionCompany_name]
  user_id: [RecruiterProfilesConnectionUser_id]
  reject_reason: [RecruiterProfilesConnectionReject_reason]
}

type RecruiterProfilesConnectionId {
  key: ID
  connection: RecruiterProfilesConnection
}

type RecruiterProfilesConnectionCreated_at {
  key: DateTime
  connection: RecruiterProfilesConnection
}

type RecruiterProfilesConnectionUpdated_at {
  key: DateTime
  connection: RecruiterProfilesConnection
}

type RecruiterProfilesConnectionStatus {
  key: String
  connection: RecruiterProfilesConnection
}

type RecruiterProfilesConnectionPosition {
  key: String
  connection: RecruiterProfilesConnection
}

type RecruiterProfilesConnectionCompany_name {
  key: String
  connection: RecruiterProfilesConnection
}

type RecruiterProfilesConnectionUser_id {
  key: ID
  connection: RecruiterProfilesConnection
}

type RecruiterProfilesConnectionReject_reason {
  key: String
  connection: RecruiterProfilesConnection
}

input RecruiterProfileInput {
  status: ENUM_RECRUITERPROFILES_STATUS
  position: String
  company_name: String
  user_id: ID
  reject_reason: String
  profile_connections: [ID]
  created_by: ID
  updated_by: ID
}

input editRecruiterProfileInput {
  status: ENUM_RECRUITERPROFILES_STATUS
  position: String
  company_name: String
  user_id: ID
  reject_reason: String
  profile_connections: [ID]
  created_by: ID
  updated_by: ID
}

input createRecruiterProfileInput {
  data: RecruiterProfileInput
}

type createRecruiterProfilePayload {
  recruiterProfile: RecruiterProfiles
}

input updateRecruiterProfileInput {
  where: InputID
  data: editRecruiterProfileInput
}

type updateRecruiterProfilePayload {
  recruiterProfile: RecruiterProfiles
}

input deleteRecruiterProfileInput {
  where: InputID
}

type deleteRecruiterProfilePayload {
  recruiterProfile: RecruiterProfiles
}

type ServiceAccessTokens {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  token: String!
  user_id: HuntdUsers
}

type ServiceAccessTokensConnection {
  values: [ServiceAccessTokens]
  groupBy: ServiceAccessTokensGroupBy
  aggregate: ServiceAccessTokensAggregator
}

type ServiceAccessTokensAggregator {
  count: Int
  totalCount: Int
}

type ServiceAccessTokensGroupBy {
  id: [ServiceAccessTokensConnectionId]
  created_at: [ServiceAccessTokensConnectionCreated_at]
  updated_at: [ServiceAccessTokensConnectionUpdated_at]
  token: [ServiceAccessTokensConnectionToken]
  user_id: [ServiceAccessTokensConnectionUser_id]
}

type ServiceAccessTokensConnectionId {
  key: ID
  connection: ServiceAccessTokensConnection
}

type ServiceAccessTokensConnectionCreated_at {
  key: DateTime
  connection: ServiceAccessTokensConnection
}

type ServiceAccessTokensConnectionUpdated_at {
  key: DateTime
  connection: ServiceAccessTokensConnection
}

type ServiceAccessTokensConnectionToken {
  key: String
  connection: ServiceAccessTokensConnection
}

type ServiceAccessTokensConnectionUser_id {
  key: ID
  connection: ServiceAccessTokensConnection
}

input ServiceAccessTokenInput {
  token: String!
  user_id: ID
  created_by: ID
  updated_by: ID
}

input editServiceAccessTokenInput {
  token: String
  user_id: ID
  created_by: ID
  updated_by: ID
}

input createServiceAccessTokenInput {
  data: ServiceAccessTokenInput
}

type createServiceAccessTokenPayload {
  serviceAccessToken: ServiceAccessTokens
}

input updateServiceAccessTokenInput {
  where: InputID
  data: editServiceAccessTokenInput
}

type updateServiceAccessTokenPayload {
  serviceAccessToken: ServiceAccessTokens
}

input deleteServiceAccessTokenInput {
  where: InputID
}

type deleteServiceAccessTokenPayload {
  serviceAccessToken: ServiceAccessTokens
}

type Settings {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  api_graphql_endpoint: String!
  api_graphql_token: String!
}

input SettingInput {
  api_graphql_endpoint: String!
  api_graphql_token: String!
  created_by: ID
  updated_by: ID
}

input editSettingInput {
  api_graphql_endpoint: String
  api_graphql_token: String
  created_by: ID
  updated_by: ID
}

input updateSettingInput {
  data: editSettingInput
}

type updateSettingPayload {
  setting: Settings
}

type deleteSettingPayload {
  setting: Settings
}

type Specializations {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
}

type SpecializationsConnection {
  values: [Specializations]
  groupBy: SpecializationsGroupBy
  aggregate: SpecializationsAggregator
}

type SpecializationsAggregator {
  count: Int
  totalCount: Int
}

type SpecializationsGroupBy {
  id: [SpecializationsConnectionId]
  created_at: [SpecializationsConnectionCreated_at]
  updated_at: [SpecializationsConnectionUpdated_at]
  name: [SpecializationsConnectionName]
}

type SpecializationsConnectionId {
  key: ID
  connection: SpecializationsConnection
}

type SpecializationsConnectionCreated_at {
  key: DateTime
  connection: SpecializationsConnection
}

type SpecializationsConnectionUpdated_at {
  key: DateTime
  connection: SpecializationsConnection
}

type SpecializationsConnectionName {
  key: String
  connection: SpecializationsConnection
}

input SpecializationInput {
  name: String
  created_by: ID
  updated_by: ID
}

input editSpecializationInput {
  name: String
  created_by: ID
  updated_by: ID
}

input createSpecializationInput {
  data: SpecializationInput
}

type createSpecializationPayload {
  specialization: Specializations
}

input updateSpecializationInput {
  where: InputID
  data: editSpecializationInput
}

type updateSpecializationPayload {
  specialization: Specializations
}

input deleteSpecializationInput {
  where: InputID
}

type deleteSpecializationPayload {
  specialization: Specializations
}

type Technologies {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  published_at: DateTime
}

type TechnologiesConnection {
  values: [Technologies]
  groupBy: TechnologiesGroupBy
  aggregate: TechnologiesAggregator
}

type TechnologiesAggregator {
  count: Int
  totalCount: Int
}

type TechnologiesGroupBy {
  id: [TechnologiesConnectionId]
  created_at: [TechnologiesConnectionCreated_at]
  updated_at: [TechnologiesConnectionUpdated_at]
  name: [TechnologiesConnectionName]
  published_at: [TechnologiesConnectionPublished_at]
}

type TechnologiesConnectionId {
  key: ID
  connection: TechnologiesConnection
}

type TechnologiesConnectionCreated_at {
  key: DateTime
  connection: TechnologiesConnection
}

type TechnologiesConnectionUpdated_at {
  key: DateTime
  connection: TechnologiesConnection
}

type TechnologiesConnectionName {
  key: String
  connection: TechnologiesConnection
}

type TechnologiesConnectionPublished_at {
  key: DateTime
  connection: TechnologiesConnection
}

input TechnologyInput {
  name: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editTechnologyInput {
  name: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createTechnologyInput {
  data: TechnologyInput
}

type createTechnologyPayload {
  technology: Technologies
}

input updateTechnologyInput {
  where: InputID
  data: editTechnologyInput
}

type updateTechnologyPayload {
  technology: Technologies
}

input deleteTechnologyInput {
  where: InputID
}

type deleteTechnologyPayload {
  technology: Technologies
}

type Translates {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  code: String!
  namespace: String!
  language: String!
  value: String
}

type TranslatesConnection {
  values: [Translates]
  groupBy: TranslatesGroupBy
  aggregate: TranslatesAggregator
}

type TranslatesAggregator {
  count: Int
  totalCount: Int
}

type TranslatesGroupBy {
  id: [TranslatesConnectionId]
  created_at: [TranslatesConnectionCreated_at]
  updated_at: [TranslatesConnectionUpdated_at]
  code: [TranslatesConnectionCode]
  namespace: [TranslatesConnectionNamespace]
  language: [TranslatesConnectionLanguage]
  value: [TranslatesConnectionValue]
}

type TranslatesConnectionId {
  key: ID
  connection: TranslatesConnection
}

type TranslatesConnectionCreated_at {
  key: DateTime
  connection: TranslatesConnection
}

type TranslatesConnectionUpdated_at {
  key: DateTime
  connection: TranslatesConnection
}

type TranslatesConnectionCode {
  key: String
  connection: TranslatesConnection
}

type TranslatesConnectionNamespace {
  key: String
  connection: TranslatesConnection
}

type TranslatesConnectionLanguage {
  key: String
  connection: TranslatesConnection
}

type TranslatesConnectionValue {
  key: String
  connection: TranslatesConnection
}

input TranslateInput {
  code: String!
  namespace: String!
  language: String
  value: String
  created_by: ID
  updated_by: ID
}

input editTranslateInput {
  code: String
  namespace: String
  language: String
  value: String
  created_by: ID
  updated_by: ID
}

input createTranslateInput {
  data: TranslateInput
}

type createTranslatePayload {
  translate: Translates
}

input updateTranslateInput {
  where: InputID
  data: editTranslateInput
}

type updateTranslatePayload {
  translate: Translates
}

input deleteTranslateInput {
  where: InputID
}

type deleteTranslatePayload {
  translate: Translates
}

type VacanciesSources {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  url: String!
  user_id: HuntdUsers
  published_at: DateTime
}

type VacanciesSourcesConnection {
  values: [VacanciesSources]
  groupBy: VacanciesSourcesGroupBy
  aggregate: VacanciesSourcesAggregator
}

type VacanciesSourcesAggregator {
  count: Int
  totalCount: Int
}

type VacanciesSourcesGroupBy {
  id: [VacanciesSourcesConnectionId]
  created_at: [VacanciesSourcesConnectionCreated_at]
  updated_at: [VacanciesSourcesConnectionUpdated_at]
  url: [VacanciesSourcesConnectionUrl]
  user_id: [VacanciesSourcesConnectionUser_id]
  published_at: [VacanciesSourcesConnectionPublished_at]
}

type VacanciesSourcesConnectionId {
  key: ID
  connection: VacanciesSourcesConnection
}

type VacanciesSourcesConnectionCreated_at {
  key: DateTime
  connection: VacanciesSourcesConnection
}

type VacanciesSourcesConnectionUpdated_at {
  key: DateTime
  connection: VacanciesSourcesConnection
}

type VacanciesSourcesConnectionUrl {
  key: String
  connection: VacanciesSourcesConnection
}

type VacanciesSourcesConnectionUser_id {
  key: ID
  connection: VacanciesSourcesConnection
}

type VacanciesSourcesConnectionPublished_at {
  key: DateTime
  connection: VacanciesSourcesConnection
}

input VacanciesSourceInput {
  url: String!
  user_id: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editVacanciesSourceInput {
  url: String
  user_id: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createVacanciesSourceInput {
  data: VacanciesSourceInput
}

type createVacanciesSourcePayload {
  vacanciesSource: VacanciesSources
}

input updateVacanciesSourceInput {
  where: InputID
  data: editVacanciesSourceInput
}

type updateVacanciesSourcePayload {
  vacanciesSource: VacanciesSources
}

input deleteVacanciesSourceInput {
  where: InputID
}

type deleteVacanciesSourcePayload {
  vacanciesSource: VacanciesSources
}

enum ENUM_VACANCIES_STATUS {
  ACTIVE
  INACTIVE
}

enum ENUM_VACANCIES_JOB_TYPE {
  FULL_TIME
  PART_TIME
}

enum ENUM_VACANCIES_JOB_CATEGORY {
  US_ONLY
  EUROPE_ONLY
  WORLDWIDE
}

type Vacancies {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  job_title: String!
  company_name: String!
  english_level_id: EnglishLevel
  job_experience_id: JobExperience
  status: ENUM_VACANCIES_STATUS!
  job_type: ENUM_VACANCIES_JOB_TYPE!
  job_category: ENUM_VACANCIES_JOB_CATEGORY!
  job_description: String
  logo: UploadFile
  salary_from: Float
  salary_to: Float
  is_top: Boolean
  published_at: DateTime
  vacancy_technologies(sort: String, limit: Int, start: Int, where: JSON): [VacancyTechnologies]
  vacancy_specializations(sort: String, limit: Int, start: Int, where: JSON): [VacancySpecializations]
}

type VacanciesConnection {
  values: [Vacancies]
  groupBy: VacanciesGroupBy
  aggregate: VacanciesAggregator
}

type VacanciesAggregator {
  count: Int
  totalCount: Int
  sum: VacanciesAggregatorSum
  avg: VacanciesAggregatorAvg
  min: VacanciesAggregatorMin
  max: VacanciesAggregatorMax
}

type VacanciesAggregatorSum {
  salary_from: Float
  salary_to: Float
}

type VacanciesAggregatorAvg {
  salary_from: Float
  salary_to: Float
}

type VacanciesAggregatorMin {
  salary_from: Float
  salary_to: Float
}

type VacanciesAggregatorMax {
  salary_from: Float
  salary_to: Float
}

type VacanciesGroupBy {
  id: [VacanciesConnectionId]
  created_at: [VacanciesConnectionCreated_at]
  updated_at: [VacanciesConnectionUpdated_at]
  job_title: [VacanciesConnectionJob_title]
  company_name: [VacanciesConnectionCompany_name]
  english_level_id: [VacanciesConnectionEnglish_level_id]
  job_experience_id: [VacanciesConnectionJob_experience_id]
  status: [VacanciesConnectionStatus]
  job_type: [VacanciesConnectionJob_type]
  job_category: [VacanciesConnectionJob_category]
  job_description: [VacanciesConnectionJob_description]
  logo: [VacanciesConnectionLogo]
  salary_from: [VacanciesConnectionSalary_from]
  salary_to: [VacanciesConnectionSalary_to]
  is_top: [VacanciesConnectionIs_top]
  published_at: [VacanciesConnectionPublished_at]
}

type VacanciesConnectionId {
  key: ID
  connection: VacanciesConnection
}

type VacanciesConnectionCreated_at {
  key: DateTime
  connection: VacanciesConnection
}

type VacanciesConnectionUpdated_at {
  key: DateTime
  connection: VacanciesConnection
}

type VacanciesConnectionJob_title {
  key: String
  connection: VacanciesConnection
}

type VacanciesConnectionCompany_name {
  key: String
  connection: VacanciesConnection
}

type VacanciesConnectionEnglish_level_id {
  key: ID
  connection: VacanciesConnection
}

type VacanciesConnectionJob_experience_id {
  key: ID
  connection: VacanciesConnection
}

type VacanciesConnectionStatus {
  key: String
  connection: VacanciesConnection
}

type VacanciesConnectionJob_type {
  key: String
  connection: VacanciesConnection
}

type VacanciesConnectionJob_category {
  key: String
  connection: VacanciesConnection
}

type VacanciesConnectionJob_description {
  key: String
  connection: VacanciesConnection
}

type VacanciesConnectionLogo {
  key: ID
  connection: VacanciesConnection
}

type VacanciesConnectionSalary_from {
  key: Float
  connection: VacanciesConnection
}

type VacanciesConnectionSalary_to {
  key: Float
  connection: VacanciesConnection
}

type VacanciesConnectionIs_top {
  key: Boolean
  connection: VacanciesConnection
}

type VacanciesConnectionPublished_at {
  key: DateTime
  connection: VacanciesConnection
}

input VacancyInput {
  job_title: String!
  company_name: String!
  vacancy_technologies: [ID]
  vacancy_specializations: [ID]
  english_level_id: ID
  job_experience_id: ID
  status: ENUM_VACANCIES_STATUS
  job_type: ENUM_VACANCIES_JOB_TYPE!
  job_category: ENUM_VACANCIES_JOB_CATEGORY!
  job_description: String
  logo: ID
  salary_from: Float
  salary_to: Float
  is_top: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editVacancyInput {
  job_title: String
  company_name: String
  vacancy_technologies: [ID]
  vacancy_specializations: [ID]
  english_level_id: ID
  job_experience_id: ID
  status: ENUM_VACANCIES_STATUS
  job_type: ENUM_VACANCIES_JOB_TYPE
  job_category: ENUM_VACANCIES_JOB_CATEGORY
  job_description: String
  logo: ID
  salary_from: Float
  salary_to: Float
  is_top: Boolean
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createVacancyInput {
  data: VacancyInput
}

type createVacancyPayload {
  vacancy: Vacancies
}

input updateVacancyInput {
  where: InputID
  data: editVacancyInput
}

type updateVacancyPayload {
  vacancy: Vacancies
}

input deleteVacancyInput {
  where: InputID
}

type deleteVacancyPayload {
  vacancy: Vacancies
}

type VacancySpecializations {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  specialization_id: Specializations
  vacancy_id: Vacancies
  published_at: DateTime
}

type VacancySpecializationsConnection {
  values: [VacancySpecializations]
  groupBy: VacancySpecializationsGroupBy
  aggregate: VacancySpecializationsAggregator
}

type VacancySpecializationsAggregator {
  count: Int
  totalCount: Int
}

type VacancySpecializationsGroupBy {
  id: [VacancySpecializationsConnectionId]
  created_at: [VacancySpecializationsConnectionCreated_at]
  updated_at: [VacancySpecializationsConnectionUpdated_at]
  specialization_id: [VacancySpecializationsConnectionSpecialization_id]
  vacancy_id: [VacancySpecializationsConnectionVacancy_id]
  published_at: [VacancySpecializationsConnectionPublished_at]
}

type VacancySpecializationsConnectionId {
  key: ID
  connection: VacancySpecializationsConnection
}

type VacancySpecializationsConnectionCreated_at {
  key: DateTime
  connection: VacancySpecializationsConnection
}

type VacancySpecializationsConnectionUpdated_at {
  key: DateTime
  connection: VacancySpecializationsConnection
}

type VacancySpecializationsConnectionSpecialization_id {
  key: ID
  connection: VacancySpecializationsConnection
}

type VacancySpecializationsConnectionVacancy_id {
  key: ID
  connection: VacancySpecializationsConnection
}

type VacancySpecializationsConnectionPublished_at {
  key: DateTime
  connection: VacancySpecializationsConnection
}

input VacancySpecializationInput {
  specialization_id: ID
  vacancy_id: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editVacancySpecializationInput {
  specialization_id: ID
  vacancy_id: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createVacancySpecializationInput {
  data: VacancySpecializationInput
}

type createVacancySpecializationPayload {
  vacancySpecialization: VacancySpecializations
}

input updateVacancySpecializationInput {
  where: InputID
  data: editVacancySpecializationInput
}

type updateVacancySpecializationPayload {
  vacancySpecialization: VacancySpecializations
}

input deleteVacancySpecializationInput {
  where: InputID
}

type deleteVacancySpecializationPayload {
  vacancySpecialization: VacancySpecializations
}

type VacancyTechnologies {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  technology_id: Technologies
  vacancy_id: Vacancies
  published_at: DateTime
}

type VacancyTechnologiesConnection {
  values: [VacancyTechnologies]
  groupBy: VacancyTechnologiesGroupBy
  aggregate: VacancyTechnologiesAggregator
}

type VacancyTechnologiesAggregator {
  count: Int
  totalCount: Int
}

type VacancyTechnologiesGroupBy {
  id: [VacancyTechnologiesConnectionId]
  created_at: [VacancyTechnologiesConnectionCreated_at]
  updated_at: [VacancyTechnologiesConnectionUpdated_at]
  technology_id: [VacancyTechnologiesConnectionTechnology_id]
  vacancy_id: [VacancyTechnologiesConnectionVacancy_id]
  published_at: [VacancyTechnologiesConnectionPublished_at]
}

type VacancyTechnologiesConnectionId {
  key: ID
  connection: VacancyTechnologiesConnection
}

type VacancyTechnologiesConnectionCreated_at {
  key: DateTime
  connection: VacancyTechnologiesConnection
}

type VacancyTechnologiesConnectionUpdated_at {
  key: DateTime
  connection: VacancyTechnologiesConnection
}

type VacancyTechnologiesConnectionTechnology_id {
  key: ID
  connection: VacancyTechnologiesConnection
}

type VacancyTechnologiesConnectionVacancy_id {
  key: ID
  connection: VacancyTechnologiesConnection
}

type VacancyTechnologiesConnectionPublished_at {
  key: DateTime
  connection: VacancyTechnologiesConnection
}

input VacancyTechnologyInput {
  technology_id: ID
  vacancy_id: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editVacancyTechnologyInput {
  technology_id: ID
  vacancy_id: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createVacancyTechnologyInput {
  data: VacancyTechnologyInput
}

type createVacancyTechnologyPayload {
  vacancyTechnology: VacancyTechnologies
}

input updateVacancyTechnologyInput {
  where: InputID
  data: editVacancyTechnologyInput
}

type updateVacancyTechnologyPayload {
  vacancyTechnology: VacancyTechnologies
}

input deleteVacancyTechnologyInput {
  where: InputID
}

type deleteVacancyTechnologyPayload {
  vacancyTechnology: VacancyTechnologies
}

type UploadFile {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  created_at: [UploadFileConnectionCreated_at]
  updated_at: [UploadFileConnectionUpdated_at]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  created_at: [UsersPermissionsUserConnectionCreated_at]
  updated_at: [UsersPermissionsUserConnectionUpdated_at]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  confirmationToken: String
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  confirmationToken: String
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | CandidateProfiles | CandidateProfilesConnection | CandidateProfilesAggregator | CandidateProfilesAggregatorSum | CandidateProfilesAggregatorAvg | CandidateProfilesAggregatorMin | CandidateProfilesAggregatorMax | CandidateProfilesGroupBy | CandidateProfilesConnectionId | CandidateProfilesConnectionCreated_at | CandidateProfilesConnectionUpdated_at | CandidateProfilesConnectionStatus | CandidateProfilesConnectionPosition | CandidateProfilesConnectionSalary | CandidateProfilesConnectionCandidate_description | CandidateProfilesConnectionExperience_description | CandidateProfilesConnectionReject_reason | CandidateProfilesConnectionUser_id | CandidateProfilesConnectionAchievements | createCandidateProfilePayload | updateCandidateProfilePayload | deleteCandidateProfilePayload | DeviceTokens | DeviceTokensConnection | DeviceTokensAggregator | DeviceTokensGroupBy | DeviceTokensConnectionId | DeviceTokensConnectionCreated_at | DeviceTokensConnectionUpdated_at | DeviceTokensConnectionToken | DeviceTokensConnectionDevice_name | DeviceTokensConnectionDevice_platform | DeviceTokensConnectionSystem_version | DeviceTokensConnectionDevice_year | DeviceTokensConnectionUser_id | DeviceTokensConnectionPublished_at | createDeviceTokenPayload | updateDeviceTokenPayload | deleteDeviceTokenPayload | EnglishLevel | EnglishLevelConnection | EnglishLevelAggregator | EnglishLevelGroupBy | EnglishLevelConnectionId | EnglishLevelConnectionCreated_at | EnglishLevelConnectionUpdated_at | EnglishLevelConnectionSlug | EnglishLevelConnectionPublished_at | createEnglishLevelPayload | updateEnglishLevelPayload | deleteEnglishLevelPayload | Features | FeaturesConnection | FeaturesAggregator | FeaturesGroupBy | FeaturesConnectionId | FeaturesConnectionCreated_at | FeaturesConnectionUpdated_at | FeaturesConnectionName | FeaturesConnectionDescription | FeaturesConnectionStatus | createFeaturePayload | updateFeaturePayload | deleteFeaturePayload | HuntdUsers | HuntdUsersConnection | HuntdUsersAggregator | HuntdUsersGroupBy | HuntdUsersConnectionId | HuntdUsersConnectionCreated_at | HuntdUsersConnectionUpdated_at | HuntdUsersConnectionEmail | HuntdUsersConnectionFirst_name | HuntdUsersConnectionLast_name | HuntdUsersConnectionCv | createHuntdUserPayload | updateHuntdUserPayload | deleteHuntdUserPayload | JobExperience | JobExperienceConnection | JobExperienceAggregator | JobExperienceGroupBy | JobExperienceConnectionId | JobExperienceConnectionCreated_at | JobExperienceConnectionUpdated_at | JobExperienceConnectionSlug | JobExperienceConnectionPublished_at | createJobExperiencePayload | updateJobExperiencePayload | deleteJobExperiencePayload | ProfileConnections | ProfileConnectionsConnection | ProfileConnectionsAggregator | ProfileConnectionsGroupBy | ProfileConnectionsConnectionId | ProfileConnectionsConnectionCreated_at | ProfileConnectionsConnectionUpdated_at | ProfileConnectionsConnectionPaid_at | ProfileConnectionsConnectionCandidate_profile_id | ProfileConnectionsConnectionRecruiter_profile_id | ProfileConnectionsConnectionStatus | ProfileConnectionsConnectionIs_payment_requested | ProfileConnectionsConnectionRecruiter_user_id | createProfileConnectionPayload | updateProfileConnectionPayload | deleteProfileConnectionPayload | RecruiterProfiles | RecruiterProfilesConnection | RecruiterProfilesAggregator | RecruiterProfilesGroupBy | RecruiterProfilesConnectionId | RecruiterProfilesConnectionCreated_at | RecruiterProfilesConnectionUpdated_at | RecruiterProfilesConnectionStatus | RecruiterProfilesConnectionPosition | RecruiterProfilesConnectionCompany_name | RecruiterProfilesConnectionUser_id | RecruiterProfilesConnectionReject_reason | createRecruiterProfilePayload | updateRecruiterProfilePayload | deleteRecruiterProfilePayload | ServiceAccessTokens | ServiceAccessTokensConnection | ServiceAccessTokensAggregator | ServiceAccessTokensGroupBy | ServiceAccessTokensConnectionId | ServiceAccessTokensConnectionCreated_at | ServiceAccessTokensConnectionUpdated_at | ServiceAccessTokensConnectionToken | ServiceAccessTokensConnectionUser_id | createServiceAccessTokenPayload | updateServiceAccessTokenPayload | deleteServiceAccessTokenPayload | Settings | updateSettingPayload | deleteSettingPayload | Specializations | SpecializationsConnection | SpecializationsAggregator | SpecializationsGroupBy | SpecializationsConnectionId | SpecializationsConnectionCreated_at | SpecializationsConnectionUpdated_at | SpecializationsConnectionName | createSpecializationPayload | updateSpecializationPayload | deleteSpecializationPayload | Technologies | TechnologiesConnection | TechnologiesAggregator | TechnologiesGroupBy | TechnologiesConnectionId | TechnologiesConnectionCreated_at | TechnologiesConnectionUpdated_at | TechnologiesConnectionName | TechnologiesConnectionPublished_at | createTechnologyPayload | updateTechnologyPayload | deleteTechnologyPayload | Translates | TranslatesConnection | TranslatesAggregator | TranslatesGroupBy | TranslatesConnectionId | TranslatesConnectionCreated_at | TranslatesConnectionUpdated_at | TranslatesConnectionCode | TranslatesConnectionNamespace | TranslatesConnectionLanguage | TranslatesConnectionValue | createTranslatePayload | updateTranslatePayload | deleteTranslatePayload | VacanciesSources | VacanciesSourcesConnection | VacanciesSourcesAggregator | VacanciesSourcesGroupBy | VacanciesSourcesConnectionId | VacanciesSourcesConnectionCreated_at | VacanciesSourcesConnectionUpdated_at | VacanciesSourcesConnectionUrl | VacanciesSourcesConnectionUser_id | VacanciesSourcesConnectionPublished_at | createVacanciesSourcePayload | updateVacanciesSourcePayload | deleteVacanciesSourcePayload | Vacancies | VacanciesConnection | VacanciesAggregator | VacanciesAggregatorSum | VacanciesAggregatorAvg | VacanciesAggregatorMin | VacanciesAggregatorMax | VacanciesGroupBy | VacanciesConnectionId | VacanciesConnectionCreated_at | VacanciesConnectionUpdated_at | VacanciesConnectionJob_title | VacanciesConnectionCompany_name | VacanciesConnectionEnglish_level_id | VacanciesConnectionJob_experience_id | VacanciesConnectionStatus | VacanciesConnectionJob_type | VacanciesConnectionJob_category | VacanciesConnectionJob_description | VacanciesConnectionLogo | VacanciesConnectionSalary_from | VacanciesConnectionSalary_to | VacanciesConnectionIs_top | VacanciesConnectionPublished_at | createVacancyPayload | updateVacancyPayload | deleteVacancyPayload | VacancySpecializations | VacancySpecializationsConnection | VacancySpecializationsAggregator | VacancySpecializationsGroupBy | VacancySpecializationsConnectionId | VacancySpecializationsConnectionCreated_at | VacancySpecializationsConnectionUpdated_at | VacancySpecializationsConnectionSpecialization_id | VacancySpecializationsConnectionVacancy_id | VacancySpecializationsConnectionPublished_at | createVacancySpecializationPayload | updateVacancySpecializationPayload | deleteVacancySpecializationPayload | VacancyTechnologies | VacancyTechnologiesConnection | VacancyTechnologiesAggregator | VacancyTechnologiesGroupBy | VacancyTechnologiesConnectionId | VacancyTechnologiesConnectionCreated_at | VacancyTechnologiesConnectionUpdated_at | VacancyTechnologiesConnectionTechnology_id | VacancyTechnologiesConnectionVacancy_id | VacancyTechnologiesConnectionPublished_at | createVacancyTechnologyPayload | updateVacancyTechnologyPayload | deleteVacancyTechnologyPayload | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnectionCreated_at | UploadFileConnectionUpdated_at | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | createUserPayload | updateUserPayload | deleteUserPayload

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  candidateProfile(id: ID!, publicationState: PublicationState): CandidateProfiles
  candidateProfiles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [CandidateProfiles]
  candidateProfilesConnection(sort: String, limit: Int, start: Int, where: JSON): CandidateProfilesConnection
  deviceToken(id: ID!, publicationState: PublicationState): DeviceTokens
  deviceTokens(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [DeviceTokens]
  deviceTokensConnection(sort: String, limit: Int, start: Int, where: JSON): DeviceTokensConnection
  englishLevel(id: ID!, publicationState: PublicationState): EnglishLevel
  englishLevels(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [EnglishLevel]
  englishLevelsConnection(sort: String, limit: Int, start: Int, where: JSON): EnglishLevelConnection
  feature(id: ID!, publicationState: PublicationState): Features
  features(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Features]
  featuresConnection(sort: String, limit: Int, start: Int, where: JSON): FeaturesConnection
  huntdUser(id: ID!, publicationState: PublicationState): HuntdUsers
  huntdUsers(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [HuntdUsers]
  huntdUsersConnection(sort: String, limit: Int, start: Int, where: JSON): HuntdUsersConnection
  jobExperience(id: ID!, publicationState: PublicationState): JobExperience
  jobExperiences(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [JobExperience]
  jobExperiencesConnection(sort: String, limit: Int, start: Int, where: JSON): JobExperienceConnection
  profileConnection(id: ID!, publicationState: PublicationState): ProfileConnections
  profileConnections(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ProfileConnections]
  profileConnectionsConnection(sort: String, limit: Int, start: Int, where: JSON): ProfileConnectionsConnection
  recruiterProfile(id: ID!, publicationState: PublicationState): RecruiterProfiles
  recruiterProfiles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [RecruiterProfiles]
  recruiterProfilesConnection(sort: String, limit: Int, start: Int, where: JSON): RecruiterProfilesConnection
  serviceAccessToken(id: ID!, publicationState: PublicationState): ServiceAccessTokens
  serviceAccessTokens(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ServiceAccessTokens]
  serviceAccessTokensConnection(sort: String, limit: Int, start: Int, where: JSON): ServiceAccessTokensConnection
  setting(publicationState: PublicationState): Settings
  specialization(id: ID!, publicationState: PublicationState): Specializations
  specializations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Specializations]
  specializationsConnection(sort: String, limit: Int, start: Int, where: JSON): SpecializationsConnection
  technology(id: ID!, publicationState: PublicationState): Technologies
  technologies(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Technologies]
  technologiesConnection(sort: String, limit: Int, start: Int, where: JSON): TechnologiesConnection
  translate(id: ID!, publicationState: PublicationState): Translates
  translates(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Translates]
  translatesConnection(sort: String, limit: Int, start: Int, where: JSON): TranslatesConnection
  vacanciesSource(id: ID!, publicationState: PublicationState): VacanciesSources
  vacanciesSources(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [VacanciesSources]
  vacanciesSourcesConnection(sort: String, limit: Int, start: Int, where: JSON): VacanciesSourcesConnection
  vacancy(id: ID!, publicationState: PublicationState): Vacancies
  vacancies(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Vacancies]
  vacanciesConnection(sort: String, limit: Int, start: Int, where: JSON): VacanciesConnection
  vacancySpecialization(id: ID!, publicationState: PublicationState): VacancySpecializations
  vacancySpecializations(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [VacancySpecializations]
  vacancySpecializationsConnection(sort: String, limit: Int, start: Int, where: JSON): VacancySpecializationsConnection
  vacancyTechnology(id: ID!, publicationState: PublicationState): VacancyTechnologies
  vacancyTechnologies(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [VacancyTechnologies]
  vacancyTechnologiesConnection(sort: String, limit: Int, start: Int, where: JSON): VacancyTechnologiesConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

type Mutation {
  createCandidateProfile(input: createCandidateProfileInput): createCandidateProfilePayload
  updateCandidateProfile(input: updateCandidateProfileInput): updateCandidateProfilePayload
  deleteCandidateProfile(input: deleteCandidateProfileInput): deleteCandidateProfilePayload
  createDeviceToken(input: createDeviceTokenInput): createDeviceTokenPayload
  updateDeviceToken(input: updateDeviceTokenInput): updateDeviceTokenPayload
  deleteDeviceToken(input: deleteDeviceTokenInput): deleteDeviceTokenPayload
  createEnglishLevel(input: createEnglishLevelInput): createEnglishLevelPayload
  updateEnglishLevel(input: updateEnglishLevelInput): updateEnglishLevelPayload
  deleteEnglishLevel(input: deleteEnglishLevelInput): deleteEnglishLevelPayload
  createFeature(input: createFeatureInput): createFeaturePayload
  updateFeature(input: updateFeatureInput): updateFeaturePayload
  deleteFeature(input: deleteFeatureInput): deleteFeaturePayload
  createHuntdUser(input: createHuntdUserInput): createHuntdUserPayload
  updateHuntdUser(input: updateHuntdUserInput): updateHuntdUserPayload
  deleteHuntdUser(input: deleteHuntdUserInput): deleteHuntdUserPayload
  createJobExperience(input: createJobExperienceInput): createJobExperiencePayload
  updateJobExperience(input: updateJobExperienceInput): updateJobExperiencePayload
  deleteJobExperience(input: deleteJobExperienceInput): deleteJobExperiencePayload
  createProfileConnection(input: createProfileConnectionInput): createProfileConnectionPayload
  updateProfileConnection(input: updateProfileConnectionInput): updateProfileConnectionPayload
  deleteProfileConnection(input: deleteProfileConnectionInput): deleteProfileConnectionPayload
  createRecruiterProfile(input: createRecruiterProfileInput): createRecruiterProfilePayload
  updateRecruiterProfile(input: updateRecruiterProfileInput): updateRecruiterProfilePayload
  deleteRecruiterProfile(input: deleteRecruiterProfileInput): deleteRecruiterProfilePayload
  createServiceAccessToken(input: createServiceAccessTokenInput): createServiceAccessTokenPayload
  updateServiceAccessToken(input: updateServiceAccessTokenInput): updateServiceAccessTokenPayload
  deleteServiceAccessToken(input: deleteServiceAccessTokenInput): deleteServiceAccessTokenPayload
  updateSetting(input: updateSettingInput): updateSettingPayload
  deleteSetting: deleteSettingPayload
  createSpecialization(input: createSpecializationInput): createSpecializationPayload
  updateSpecialization(input: updateSpecializationInput): updateSpecializationPayload
  deleteSpecialization(input: deleteSpecializationInput): deleteSpecializationPayload
  createTechnology(input: createTechnologyInput): createTechnologyPayload
  updateTechnology(input: updateTechnologyInput): updateTechnologyPayload
  deleteTechnology(input: deleteTechnologyInput): deleteTechnologyPayload
  createTranslate(input: createTranslateInput): createTranslatePayload
  updateTranslate(input: updateTranslateInput): updateTranslatePayload
  deleteTranslate(input: deleteTranslateInput): deleteTranslatePayload
  createVacanciesSource(input: createVacanciesSourceInput): createVacanciesSourcePayload
  updateVacanciesSource(input: updateVacanciesSourceInput): updateVacanciesSourcePayload
  deleteVacanciesSource(input: deleteVacanciesSourceInput): deleteVacanciesSourcePayload
  createVacancy(input: createVacancyInput): createVacancyPayload
  updateVacancy(input: updateVacancyInput): updateVacancyPayload
  deleteVacancy(input: deleteVacancyInput): deleteVacancyPayload
  createVacancySpecialization(input: createVacancySpecializationInput): createVacancySpecializationPayload
  updateVacancySpecialization(input: updateVacancySpecializationInput): updateVacancySpecializationPayload
  deleteVacancySpecialization(input: deleteVacancySpecializationInput): deleteVacancySpecializationPayload
  createVacancyTechnology(input: createVacancyTechnologyInput): createVacancyTechnologyPayload
  updateVacancyTechnology(input: updateVacancyTechnologyInput): updateVacancyTechnologyPayload
  deleteVacancyTechnology(input: deleteVacancyTechnologyInput): deleteVacancyTechnologyPayload

  """Delete one file"""
  deleteFile(input: deleteFileInput): deleteFilePayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

"""The `Upload` scalar type represents a file upload."""
scalar Upload
